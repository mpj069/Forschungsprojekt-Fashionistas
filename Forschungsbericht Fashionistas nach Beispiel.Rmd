---
title: "Forschungsbericht Modelabels"
author: "Swaran Sandhu"
date: "10-03-2022"
output:
  word_document:
    toc: yes
    toc_depth: '3'
  pdf_document:
    toc: yes
    toc_depth: '3'
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 3
    number_sections: yes
subtitle: Analyse des Beziehungsnetzwerks eines Semesters
editor_options: 
  markdown: 
    wrap: 72
---
Zehra
**Anleitung und Umgang mit dem Dokument:**

Dies ist ein Beispiel, wie ein Forschungsbericht aussehen könnte. Bitte
verwenden Sie die Vorlagen-Datei für die Struktur. Hier arbeite ich
exemplarisch an einem Code-Beispiel die wichtigsten Analyse-Schritte ab.
Dies ist nur ein Beispiel und wird für jedes Projekt unterschiedlich
ausfallen. Die Projektteams müssen selbst ihren Schwerpunkt setzen. Die
Forschungsfrage definiert den Aufbau und die Schwerpunktsetzung des
Berichts mit. Achten Sie bitte darauf, dass die Datenerhebung und der
Datenzugang klar und nachvollziehbar beschrieben wird ebenso wie die
Operationalisierung des Codebuchs.

Die Visualisierungen dienen hier nur der Illustration einzelner
Schritte. In ihrem Forschungsprojekt fokussieren Sie sich auf einige
wenige ausgewählte Fragstellungen. Die Visualisierung steht erst am Ende
des Netzwerks und wird meist nur aussagekräftig durch den Vergleich mit
Teilnetzwerken.

Für dieses Beispiel erstelle ich für die Hauptkapitel das Netzwerk
teilweise neu, d.h. **der Datensatz wird neu eingelesen**. Das ist nicht
zwingend notwendig, stellt aber sicher, dass die Datenbasis immer
bereinigt ist. Achten Sie bitte auch darauf, R regelmäßig neu zu starten
und die eingespielten Werte (im Environment) zu löschen. Am einfachste
geht das, wenn Sie unter dem Run-Befehl \> Restart R and run all chunks
angeben. Dann können Sie sicher sein, dass nur die aktuellen Werte
erfasst werden.

Bitte übernehmen Sie den **Header** aus diesem Dokument, das ist der
allererste Abschnitt aus dem Dokument mit "title:" etc. komplett. Dann
wird Ihr Dokument automatisch richtig mit Inhaltsverzeichnis etc.
erstellt. Der **YAML-Header** muss genau so übernommen werden. Natürlich
müssen Sie auch knitr und pandoc installiert haben.

Denken Sie bei Markdown immer an folgendes:

1.  Verwenden Sie ab RStudio 4.1 **Visual Markdown**, dann ist die
    Bearbeitung des Dokuments deutlich einfacher.
2.  **Überschriften** setzen mit \#, \#\#, \#\#\# (diese werden
    automatisch im Inhaltsverzeichnis übernommen), also keine
    umständliche Fettung
3.  **Code-Chunks** eindeutig benennen, damit diese schneller gefunden
    werden. Die Namen der Chunks müssen **eindeutig** sein und dürfen
    sich nicht doppeln.
4.  Nicht immer ist eine Grafik/Visualisierung sinnvoll und zielführend:
    nur dann, wenn wirklich wichtig.
5.  Kommentierungen im Code immer dann, wenn die Schritte
    nachvollziehbar gemacht werden: also nicht in jeder Zeile, vor allem
    wenn der Code quasi reproduziert wird.
6.  Hier eine gute [Anleitung](https://rmarkdown.rstudio.com/) für gute
    RMarkdown-Dokumente. Besonders elegant ist es, wenn Sie die
    berechneten Werte direkt in die Beschreibung übernehmen, d.h. jedes
    berechnete Objekt lässt sich direkt
7.  Abgabe auf **Moodle** in einer Zip-Datei als **RMarkdown-Dokument**,
    gemeinsam mit den **Original-Dateien** der Edge- und Nodelist und
    dem **Codebuch** sowie dem **Link auf das Github-Verzeichnis**, in
    dem alle Daten liegen.

Achten Sie auf die Einstellungsmöglichkeiten der **Code-Chunks**: nicht
immer ist es sinnvoll, sich alle Ergebnisse anzeigen zu lassen: dies
lässt sich gut bei den Einstellungen der Chunks steuern, ebenso wie die
Abbildungsgröße.

*\*\*\* Die Anleitung und die Anmerkungen natürlich löschen vor Abgabe
\*\*\**

**Abstract und Keywords**\
Wir analysieren die Beziehungsnetzwerke innerhalb eines gerichteten,
one-mode Netzwerks von 38 Studierenden des Studiengangs CR/PR an der
Hochschule der Medien, Stuttgart. Die Beziehungsdimensionen umfassen -
angelehnt an die Studie von Krackhardt 1987 ein Zusammenarbeits- und
Ratsuche Netzwerk. Ergänzend wurden (fiktive) Liebesbeziehungen unter
den Studierenden untersucht. Die Analyse zeigt, dass das Gesamtnetzwerk
in kleinere, spezifische Cliquen zerfällt, die stark anlassbezogen sind.
Besonders bei der Ratsuche zeigt sich eine starke Orientierung an
einigen Personen, die wahrscheinlich die Funktion des oder der
Semestersprecher übernehmen und damit eine Meinungsführer-Rolle inne
haben.

Keywords: Netzwerkanalyse, Studierende, Präferenznetzwerke, Cliquen,
Meinungsführer

# Einleitung

Wir untersuchen die wichtigsten Akteure in einem studentischen Netzwerk
aus dem Studiengang CR/PR, 3. Semester. Dabei interessiert uns
besonders, ob es besonders zentrale Akteure innerhalb des Netzwerks
gibt. Für das Netzwerk wurden 38 Studierende mit einem Fragebogen nach
soziodemographischen Variablen (Alter, Geschlecht, Haarfarbe,
Augenfarbe) sowie Verhaltensmuster (Vertiefungsrichtung, Konsum von
Tabakwaren, Vorhandensein von Tattoos) befragt. Auf der Beziehungsebene
interessiert uns, wer mit präferiert zusammenarbeitet, wer besonders um
Rat gefragt wird und wer eine Liebesbeziehung innerhalb des Netzwerks
hat.

# Vorarbeiten und vergleichbare Studien

## Forschungsstand

Das Forschungsdesign lehnt sich zum einen an die lange Tradition der
Netzwerkanalyse in der Schulforschung an (Dunkake 2012). Es greift zudem
die klassische Studie von Krackhardt (1987) auf, der ein Ratsuche und
Unterstützungsnetzwerk in einem Unternehmen untersuchte.

## Arbeitshypothesen

Wir gehen von folgenden Arbeitshypothesen aus:

H1 Ratsuche: Der Knoten mit dem höchsten Indegree hat wahrscheinlich die
Funktion des Semestersprechers.

H2: Die Zusammenarbeit orientiert sich primär an Homophilie, d.h. z.B.
die gleiche Vertiefungsrichtung.

H3: Das Netzwerk zerfällt anlassbezogen bzw. situativ in kleinere
Cliquen.

Die Analyse einen überwiegend explorativen Charakter, um Muster in den
Beziehungen untersuchen.

# Datenerhebung: Zugang, Bereinigung und Codebuch

## Datenzugang, -berenigung und Codebuch

Studierende wurden innerhalb der Veranstaltung 226305a vom Dozierenden
mit einem Online-Fragebogen im Sommersemester 2017 befragt.

Der Datensatz wurde anschließend anonymisiert. Die Relationen Ratsuche
und Zusammenarbeit sind erhalten geblieben, die Beziehungen Liebe sind
fiktiv. Der Datensatz ist unter
[Github](https://github.com/hdm-crpr/226305/tree/master/data/crpr2)
verfügbar. Das
[Codebuch](https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md)
beschreibt die Variablen, Relationen und Gewichte des Netzwerks und ist
ebenfalls auf Github hinterlegt.

# Analyse und Interpretation

## Das Gesamtnetzwerk

Das Gesamtnetzwerk umfasst 38 Knoten und 176 Beziehungen (siehe
igraph-Objekt). Es ist gerichtet und gewichtet.

```{r Gesamnetzwerk erstellen, include=FALSE}

library(igraph)

# Einlesen der Edge- und Nodelist
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

# Matrix erstellen
edgematrix <-as.matrix(el)

# Zusammenführen von Edge- und Nodelist als igraph-Objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s
```

```{r Beschreibung des Netzwerks}
# Parameter zu Beschreibung des Netzwerks

## ist das Netzwerk bereits vereinfacht?
is.simple(s)

## besteht das Netzwerk aus Komponenten?
## wenn ja, wie vielen?
is.connected(s)
components(s)

## Dichte des Netzwerks
edge_density(s, loops=FALSE)

## Umfang des Netzwerks
diameter(s)

## Pfaddistanzen (Distance)
farthest_vertices(s)
```

Das Hauptnetzwerk besteht aus zwei Komponenten mit 32 und 6 Knoten, die
nicht miteinander verbunden sind. Die Dichte im Netzwerk beträgt 12,51
Prozent von allen möglichen Verbindungen. Die maximale Pfaddistanz hat
18 Schritte.

```{r Einfache Visualisierung des erstellten Objekt, fig.height=6, fig.width=9}

# Pro-Tipp: die Ausgabe jedes "chunks" lässt sich über das Rädchen direkt unter der Chunk-Beschreibung einstellen. Hier habe ich die Bildfläche auf 6 zu 9 Inches eingestellt, d.h. das Netzwerk wird automatisch auf eine Fläche von 6 auf 9 Inches geplottet. Für den Anfang empfehle ich immer bei Netzwerken bis 50 Knoten mit dem Kamada-Kawai Algorithmus zu arbeiten, weil hier die Knoten immer an die gleiche Position gesetzt werden und wir dadurch Abweichungen besser erkennen können.

# mit dem Befehl set.seed=XXX erreichen Sie, dass die Visualisierung immer gleich aussieht, sofern die gleichen Seeds verwendet werden.

plot(
  set.seed=123,
  s,
  asp=0, 
  layout=layout_with_kk,
  vertex.size=10,
  main ="Übersicht Gesamtnetzwerk")
```

### Netzwerke vereinfachen

Der erste Überblick zeigt, dass das Netzwerk schnell unübersichtlich
wird, weil hier drei Beziehungsarten mit zum Teil mehreren Gewichten in
einer Abbildung dargestellt werden.

Deshalb ist es sinnvoll, ein vereinfachtes Gesamtnetzwerk zu erstellen.
Vereinfacht bedeutet, dass die unterschiedlichen Beziehungsarten
ignoriert werden und dafür die Gewichte des Hilfs- und Ratsuche Netzwerk
zusammengefasst werden (um das Ergebnis nicht zu verfälschen, wird das
Beziehungsnetzwerk vorher gelöscht)

```{r Vereinfachtes Gesamtnetzwerk erstellen mit simplify und Visualisierung}

# Gesamtnetzwerk erstellen
# Der Code wird hier nur eingefügt, falls der Chunk später alleine weiterverwendet wird.

library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)

# simplify Gesamtnetzwerk 
# Um die Ergebnisse der Gewichte nicht zu verfälschen, werden die Edge-Attribute relation und complicated gelöscht.
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(ss, "complicated")
list.edge.attributes(ss)

# mit dem Befehl simplify() lassen sich Edge-Attribute wie das Gewicht zusammenfassen. Damit ist zwar nicht mehr nachvollziehbar, um welche Beziehung es sich handelt. Dafür lassen sich die Beziehungsstärken aber besser abbilden. Dies ist später für die Analyse von dyadischen Beziehungen wichtig.

is_simple(ss)
s_sim <- simplify(ss, edge.attr.comb=c(weight="sum"))

is_simple(s_sim)
s_sim

# die aggregierten Werte für weight von s_sim werden deutlich.
list.edge.attributes(s_sim)
edge.attributes(s_sim)$weight

# Hat das Netzwerk Componenten?
is_connected(s_sim)
```

Die Anzahl der Knoten ist gleich geblieben (38), aber die Anzahl der
Kanten hat sich auf 124 reduziert. Die Verteilung des Gewichts lässt
klare Präferenzen innerhalb des Netzwerks zwischen einzelnen Dyaden
zeigen. Diese Vorselektion ist später wichtig, um starke Beziehungspaare
innerhalb des Netzwerks zu analysieren.


**Nur starke Beziehungen im Gesamtnetzwerk**

Für dieses Netzwerk sollen nun nur noch starke Beziehungen mit einem
Gewicht von \>= 6 angezeigt werden. Damit wird das Netzwerk in ein neues
Teilnetzwerk zerlegt, das nur noch aus starken Beziehungen besteht:

```{r Starke Beziehungen im Gesamtnetzwerk, fig.height=6, fig.width=10}

# erstellt ein Teilnetzwerk nur aus starken Beziehungen
s_sim_strong <- subgraph.edges(s_sim, E(s_sim)[weight>=6]) 
s_sim_strong
edge.attributes(s_sim_strong)$weight

plot(s_sim_strong,
     asp=0,
     layout=layout_with_kk,
     #vertex.size=3,
     vertex.frame.color=NA,
     vertex.color="lightgreen",
     vertex.label.color="grey20",
     vertex.label.cex=3,
     #edge.arrow.size=2,
     edge.color="lightgreen",
     edge.width=E(s_sim_strong)$weight/2,
     edge.curved=.3,
     edge.curved=curve_multiple(s_sim_strong),
     main="Gesamtnetzwerk: Starke Beziehungen", 
      sub = "Gewicht >= 6",
      cex.main = 2, col.main= "black",
      cex.sub = 2, font.sub = 3, col.sub = "black")


```

```{r Hervorhebung der populärsten Knoten im Netzwerk, fig.height=6, fig.width=10}

# mit der Auswahl der Knoten lassen sich deren Rahmenfarben spezifisch angeben
V(s_sim)[V(s_sim)$name == 6]$color <- "green"
V(s_sim)[V(s_sim)$name == 18]$color <- "red"

plot(s_sim,
     layout=layout_in_circle,
     vertex.size=degree(s_sim),
     vertex.label.cex=2,
     # vertex.frame.color=NA,(muss ausgeschaltet sein, damit die Knoten visualisiert werden können
     edge.arrow.size=.5,
     edge.color="grey80",
     edge.width=E(s_sim)$weight/2, #halbiert den Wert der Gewichte, um eine bessere Darstellung zu ermöglichen
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     )

title("Gesamtnetzwerk vereinfacht", 
      sub = "beliebteste Knoten in grün (stärkste Beziehungen) und rot (höchste Degrees)",
      cex.main = 2, col.main= "black",
      cex.sub = 2, font.sub = 3, col.sub = "black")


```

```{r Auslesen von Attributen}
# Beispiel für das Vertex-Attribut Geschlecht
vertex.attributes(s)$sex
edge.attributes(s)$weight

# wichtig: sind keine Werte gesetzt, dann behandelt igraph den Wert als NA, also not available. Das ist wichtig für die Kalkulation der Netzwerkbeziehungen. Complicated ist ein Wert der sich nur auf das Teilnetzwerk love bezieht und spielt deshalb für die anderen 2x76 Beziehungen keine Rolle. 

```


# Analyse der Teilnetzwerke (Marie Johnson)

## Teilnetzwerk nach Edge- Attributen

Für unsere Teilnetzwerke war es uns wichtig, die verschiedenen Attribute der DesignerInnen genauer zu betrachten. Die Ränge der DesignerInnen basieren auf deren Position, welche sie bei dem jeweiligen Modelabel einnehmen bzw. einnahmen. Die vertretenden Ränge sind: founder, assistant, und director.

Die verschiedenen Ränge haben wir mit den Zahlen 1-3 codiert (1 = Assistenz, 2 = Creative Director, 3 = founder).

```{r Kantenattribute filtern }

# Netzwerk aufrufen
d
# Vertex-Attribute untersuchen
list.vertex.attributes(d)
# Kantenattribute filtern
list.edge.attributes(d)
edge.attributes(d)$position
```

### Teilnetzwerk Assistant

Das assistant Attribut beschreibt jegliche untere Ränge wie den eines normalen Designers, einem Praktikanten, oder einer Assistenz.

```{r Teilnetzwerk Assistant}

#Einlesen der Edge-und Nodelist
library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/assistant%20Teilnetzwerk%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/assistant%20Teilnetzwerk%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
#Matrix umwandeln
edgematrix <- as.matrix(edges)
assistant <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
plot(assistant)

#Anzahl der Knoten im Teilnetzwerk Assistant
assistant_nodes <- vcount(assistant)
assistant_nodes
#Das Teilnetzwerk hat 45 Knoten. Es gibt also 45 Assistenten in unserem Designernetzwerk.

#Anzahl der Kanten im Teilnetzwerk
assistant_edges <- ecount(assistant)
assistant_edges
# Das Teilnetzwerk hat 30 Kanten.
```

### Teilnetzwerk Director

Das Teilnetzwerk director beschreibt die Designer mit der größten Entscheidungsmacht in einem Modelabel.

```{r Teilnetzwerk Directors}

#Teilnetzwerk director erstellen
library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/director%20Teilnetzwerk%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/director%20Teilnetzwerk%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)
director <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
plot(director)

#Anzahl der Knoten im Teilnetzwerk director
director_nodes <- vcount(director)
director_nodes
#Das Teilnetzwerk hat 48 Knoten. 

#Anzahl der Kanten im Teilnetzwerk director
director_edges <- ecount(director)
director_edges
# Das Teilnetzwerk hat 32 Kanten.

```

### Teilnetzwerk Founder

Die Founder haben das Label, in dem sie tätig sind, gegründet.

```{r Teilnetzwerk Founder}

#Teilnetzwerk founder erstellen
library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/founder%20Teilnetzwerk%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/founder%20Teilnetzwerk%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)
founder <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
plot(founder)

#Anzahl der Knoten im Teilnetzwerk founder
founder_nodes <- vcount(founder)
founder_nodes
#Dieses Teilnetzwerk hat 62 Knoten

#Anzahl der Kanten im Teilnetzwerk founder
founder_edges <- ecount(founder)
founder_edges
#Das Teilnetzwerk hat 33 Kanten.
```

### Vergleich der drei Teilnetzwerke

```{r Vergleich}

#Visualisierung der 3 Teilnetzwerke festlegen
par(mfrow=c(1,3), mar=c(2,0,2,0))

plot(assistant, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="magenta",
     edge.width=E(assistant)$weight,
     vertex.color="pink",
     vertex.frame.color=NA,
     main= "Teilnetzwerk Assistant")

plot(director,layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="darkgreen",
     edge.width=E(director)$weight,
     vertex.color="lightgreen",
     vertex.frame.color=NA,
     main= "Teilnetzwerk Director")

plot(founder,layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="lightblue",
     edge.width=E(founder)$weight,
     vertex.color="darkblue",
     vertex.frame.color=NA,
     main= "Teilnetzwerk Founder")
     
     
```
### Reziprozität
```{r Reziprozität der Teilnetzwerke}
??reciprocity
reciprocity(founder) # O da kein gerichtetes Netzwerk
reciprocity(assistant)
reciprocity(director)
```



## Teilnetzwerke nach Node-Attributen

Für die Teilnetzwerke nach Node Attributen haben wir uns verschiedene Attribute rausgesucht, um die verschiedenen DesignerInnen noch besser vergleichen zu können. Die ausschlaggebendsten Node- Attribute, die wir uns für diese Analyse rausgesucht haben,sind die Attribute des Geschlechts, und des Bildungsgrades. Wir haben auch ein neues Teilnetzwerk für unsere Inspirationen der DesignerInnen, den Musen, erstellt.

### Teilnetzwerke nach Bildungsgrad

Die von uns recherchierten DesignerInnen verfügen alle über unterschiedliche Bildungsabschlüsse. Dieses Edge-Attribut codierten wir mit "scholar". Die verschiedenen Abschlüsse wurden unterschiedlich gewichtet:

1 = talent (Der/Die DesignerIn verfügt über Taltent, hat jedoch keinen schulischen Abschluss im Bereich der Mode.)

2 = internship/workexperience (Der/Die DesignerIn hat eventuell ein Praktikume erledigt, oder ist schon lange in der Modebranche tätig.)

3 = degree (Der/Die DesignerIn hat einen Abschluss an einer Modeschule oder einer vergleichbaren Institution erworben.)

```{r Teilnetzwerk scholar}

#Teilnetzwerk Scholar erstellen
library(igraph)
edges <- read.csv("https://rawgithubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Edgelist%20(1).csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://rawgithubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Nodelist%20(1).csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)

#Node-Attribute festlegen und Scholar Knoten suchen
list.vertex.attributes(d)

vertex_attr(d)$scholar

#nur Talente
d_talents <- delete_vertices(d, V(d)[scholar < "1"] )
d_talents

```

Es gibt insgesamt 48 Talente, welche keine schulische Ausbildung im Bereich der Mode absolviert haben.

```{r Teilnetzwerk PraktikantInnen}
#Teilnetzwerk der PraktikantInnen
d_intern <- delete_vertices(d, V(d)[scholar != "2"] )
d_intern

```

Es gibt insgesamt 4 Designer, welche als PraktikantInnen oder ArbeiterInnen mit Berufserfahrung im Bereich der Mode arbeiten.

```{r Teilnetzwerk DesignerInnen mit Abschluss}
d_degree <- delete_vertices(d, V(d)[scholar > "3"] )
d_degree

```

Es gibt insgesamt 22 DesignerInnen, welche einen Abschluss an einer Modeschule besitzen.

### Visualisierung der 3 Netzwerke

```{r}
par(mfrow=c(1,3), mar=c(2,0,2,0))

plot(d_talents,
     asp=0,
     layout=layout_with_kk,
     edge.color="blue",
     edge.arrow.size=.3,
     edge.width=E(d_talents)$weight,
     vertex.color="pink",
     vertex.frame.color=NA,
     vertex.size=degree(d_talents),
     vertex.label.cex=1,
     main="Teilnetzwerk: Talente ohne Abschluss")

plot(d_intern,
     asp=0,
     layout=layout_with_kk,
     edge.color="red",
     edge.arrow.size=.3,
     edge.width=E(d_intern)$weight,
     vertex.color="green",
     vertex.frame.color=NA,
     vertex.size=degree(d_intern),
     vertex.label.cex=1,
     main="Teilnetzwerk: PraktikantInnen")

plot(d_degree,
     asp=0,
     layout=layout_with_kk,
     edge.color="brown",
     edge.arrow.size=.3,
     edge.width=E(d_degree)$weight,
     vertex.color="magenta",
     vertex.frame.color=NA,
     vertex.size=degree(d_degree),
     vertex.label.cex=1,
     main="Teilnetzwerk: AbsolventInnen")
```

### Teilnetzwerke nach Transfers

Auch die einzelnen Transfers der DesignerInnen schauten wir uns etwas genauer an. Diese wurden mit "transfer" codiert. Die Anzahl der transfers wurde unterschiedlich gewichtet:

1 = Der/Die DesignerIn hat direkt die eigene Marke gegründet 2 = Der/Die DesignerIn hat die Marke ein mal gewechselt 3 = Der/Die DesignerIn hat die Marke zwei mal gewechselt 4 = Die Marke wurde drei oder mehrere Male gewechselt.

```{r Teilnetzwerk Transfers }

library(igraph)
library(igraph)
edges <- read.csv("https://rawgithubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Edgelist%20(1).csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://rawgithubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Nodelist%20(1).csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)

#Transfer Attribute festlegen
list.vertex.attributes(d)

vertex_attr(d)$transfer

# Transfers festlegen
ownbrand <- delete_vertices(d, V(d)[transfer > "1"] )
onetransfer <- delete_vertices(d, V(d)[transfer != "2"])
twotransfers <- delete_vertices(d, V(d)[transfer != "3"] )
threetransfers <- delete_vertices(d, V(d)[transfer < "4"] )
```

### Visualisierungen der Teilnetzwerke

```{r Visualisierung Teilnetzwerke Transfers}
par(mfrow=c(1,3), mar=c(2,0,2,0))

plot(ownbrand,
     asp=0,
     layout=layout_with_kk,
     edge.color="blue",
     edge.arrow.size=.3,
     edge.width=E(ownbrand)$weight,
     vertex.color="pink",
     vertex.frame.color=NA,
     vertex.size=degree(ownbrand),
     vertex.label.cex=1,
     main="Teilnetzwerk: keine Transfers")

plot(onetransfer,
     asp=0,
     layout=layout_with_kk,
     edge.color="red",
     edge.arrow.size=.3,
     edge.width=E(onetransfer)$weight,
     vertex.color="green",
     vertex.frame.color=NA,
     vertex.size=degree(onetransfer),
     vertex.label.cex=1,
     main="Teilnetzwerk: Ein Wechsel")

par(mfrow=c(1,3), mar=c(2,0,2,0))

plot(twotransfers,
     asp=0,
     layout=layout_with_kk,
     edge.color="brown",
     edge.arrow.size=.3,
     edge.width=E(twotransfers)$weight,
     vertex.color="magenta",
     vertex.frame.color=NA,
     vertex.size=degree(twotransfers),
     vertex.label.cex=1,
     main="Teilnetzwerk: Zwei Wechsel")

plot(threetransfers,
     asp=0,
     layout=layout_with_kk,
     edge.color="blue",
     edge.arrow.size=.3,
     edge.width=E(threetransfers)$weight,
     vertex.color="black",
     vertex.frame.color=NA,
     vertex.size=degree(threetransfers),
     vertex.label.cex=1,
     main="Teilnetzwerk: Drei oder mehr Wechsel")

```

### Teilnetzwerke nach Geschlecht Die Geschlechter der DesignerInnen und Musen unterteilten wir in drei Kategorien:

1 = weiblich 2 = männlich 3 = divers

Diese wurden mit den Werten 1-3 codiert. Diese Werte sollen jedoch nicht als gewichtet gesehen werden. Die Nummerierung dient ausschließlich der Unterscheidung der Geschlechter.

```{r Teilnetzwerk gender}
library(igraph)
edges <- read.csv("https://rawgithubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Edgelist%20(1).csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://rawgithubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Nodelist%20(1).csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)

#Geschlechter rausfiltern
list.vertex.attributes(d)

vertex_attr(d)$sex

#Teilnetzwerk der weiblichen Designer
d_fem <- delete_vertices(d, V(d)[sex != 1] )

#Visualisierung des weiblichen Designer-Netzwerks
plot(d_fem,
     asp=0,
     layout=layout_with_kk,
     edge.color="purple",
     edge.arrow.size=.3,
     edge.width=E(d_fem)$weight,
     vertex.color="pink",
     vertex.frame.color=NA,
     vertex.size=degree(d_fem),
     vertex.label.cex=1,
     main="Teilnetzwerk: Weiblichle Designer")

#Es gibt nur 6 weibliche Designer

#Männliche Designer
d_masc <- delete_vertices(d, V(d)[sex != 2] )
d_masc

#Visualisierung der männlichen Designer
plot(d_masc,
     asp=0,
     layout=layout_with_kk,
     edge.color="darkblue",
     edge.arrow.size=.3,
     edge.width=E(d_masc)$weight,
     vertex.color="blue",
     vertex.frame.color=NA,
     vertex.size=degree(d_masc),
     vertex.label.cex=1,
     main="Teilnetzwerk: Männliche Designer")

#Anzahl männliche Designer
masc_nodes <- vcount(d_masc)
masc_nodes

#Es gibt 16 männliche Designer


#Diverse Designer
d_div <- delete_vertices(d, V(d)[sex < 3] )
d_div

#Visualisierung diverse Designer
plot(d_div,
     asp=0,
     layout=layout_with_kk,
     edge.color="darkgreen",
     edge.arrow.size=.3,
     edge.width=E(d_div)$weight,
     vertex.color="green",
     vertex.frame.color=NA,
     vertex.size=degree(d_div),
     vertex.label.cex=1,
     main="Teilnetzwerk: Diverse Designer")


```

### Teilnetzwerk Musen

Die Musen stellen die Quellen der Inspiration der DesignerInnen dar. Sie wurden durch ihr Geschlecht unterschieden.

```{r Teilnetzwerk Muse}

#Teilnetzwerk Muse erstellen
library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/muse%20Teilnetzwerk%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/muse%20Teilnetzwerk%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)
muse <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
plot(muse)

#Kanten und Knoten zählen
muse_nodes <- vcount(muse)
muse_nodes
#Es gibt 76 Musen.

muse_edges <- ecount(muse)
muse_edges
#Es gibt 63 Kanten.

#Teilnetzwerk Muse visualisieren
plot(muse, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="red",
     edge.width=E(muse)$weight,
     vertex.color="purple",
     vertex.frame.color=NA,
     main= "Teilnetzwerk Muse")

```

```{r Degree Muse}
# Degree Teilnetzwerk muse
degree(muse, mode = "all")
which.max(degree(muse, mode = "all"))


```

Die Degree-Analayswe hat ergeben,dass Kate Moss den höchsten Degree Wert hat. Sie ist die beliebteste Muse unter den DesignerInnen, und ist somit von allen Musen am besten vernetzt.

```{r Indegree Muse}
# Indegree Teilnetzwerk muse
degree(muse, mode="in")
which.max(degree(muse, mode = "in"))
```

Chanel ist die beliebteste Marke unter den Musen.

```{r Betweenness und Closeness Muse}
## Betweenness und Closeness
betweenness(muse)
which.max(betweenness(muse))
close <- closeness(muse, mode="all")
close
which.max(close)
```

Dior stellt als Marke die meisten Verbindungen zwischen den Musen und DesignerInnen her.


## Komponente, Cluster und CLiquen
Da man gewisse Knoten nach gewissen Kriterien sortieren kann, haben wir unser Modenetzwerk auf Komponente untersucht.

### Komponente
```{r Komponente}
#Anzahl der Komponente
is_connected(d)
#False

count_components(d)
#16

#Verschiedenen Gruppen der DesignerInnen
d_groups <- groups(components(d))
d_groups

#Analyse der Verteilung der Komponenten
components(d, mode = c("weak", "strong"))



```
In unserem Netzwerk existieren keine isolierten Knoten. Es gibt 16 Komponente Die genaue Analyse zeigt, dass Komponente 3 die größte Komponente , mit 6 Knoten bildet. 

### Visualisieren der Komponente

```{r}

#Netzwerk vereinfachen
decompose.graph(d) 

dd <- delete_edge_attr(d, "position")
dd <- delete_edge_attr(d, "year")
d_sim <- simplify(dd, edge.attr.comb = list(weight="sum"))
is_simple(d_sim) #TRUE

is_connected(d_sim) #FALSE

#Anzahl der Clusters
clusters(d_sim) #16 Stück

#Komponenten auftrennen
d_comp <- decompose.graph(d_sim)
d_comp

# Größter und kleinere Komponente neu benennen

d_comp3 <- d_comp [[3]]
d_comp16 <- d_comp [[16]]

#Komponente visualisieren
par(mfrow=c(1,2), mar=c(0,0,4,0))

plot(d_comp3,
     edge.arrow.size=.4,
     edge.color="gold",
     vertex.color="gold",
     vertex.frame.color="pink",
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(d_comp3),
     main="Größte Komponente")

plot(d_comp16,
     edge.arrow.size=.4,
     edge.color="lightgreen",
     vertex.color="lightgreen",
     vertex.frame.color="purple",
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(d_comp16),
     main="Kleinere Komponente")

#Dichte der beiden Komponente
edge_density(d_sim) #0.0141844

edge_density(d_comp16) #0.5

edge_density(d_comp3) #0.16



```
Durch die Bestimmung der Komponente, und Berechnung deren Dichte lässt sich zeigen, dass die größte Komponente eine deutlich höhere Dichte (0.5) als das Gesamtnetzwerk hat (0.014). Dies zeigt, dass Teilkomponente stärker vernetzt sein können, als ein Gesamtnetzwerk.

###Cluster
Nun berrechnen wir die Teilcluster innerhalb der Komponenten.
```{r}
#Berechnung des Clusters
plot(d_comp3, vertex.color="pink", main="Komponente 3")

#Cluster Walktrap
?cluster_walktrap()

#Berechnung der Cluster innerhalb von Komponente 3
cl <- cluster_walktrap(d_comp3)
modularity(cl) #0.26

membership(cl)

plot(cl,d_comp3,
     edge.arrow.size=.2,
     main="Cluster-Walktrap Analyse von Komponente 3")
```
Durch die Walktrap Analyse kann man sehen, dass in der Teilkomponente 3 alle Knoten durch einen Knoten verbunden sind. Dieser Knoten ist Gucci. 

### Communities

Bei der Berechnung von Communities sucht man eng verbundene Kleingruppen in einem Netzwerk.

```{r Communities}
#Es gibt 16 Clusters

#Komponente aufteilen
d_comp <- decompose.graph(d)
d_comp

cl <- cluster_walktrap(d_comp3)
modularity(cl)
membership(cl)

#Cluster berechnen
plot(d_comp3,
     edge.arrow.size=.3,
     vertex.color="purple",
     vertex.frame.color=NA,
     main="Komponente3 (via Communities)")

#Cluster innerhalb der Community
?communities()
  membership(cl)

#Größen der Communites
  sizes(cl) #1 2 3 und 2 2 2
  
communities(cl)
# Frida Gianni und Fendi, Christopher Bailey und Burberry und Tom Ford und Gucci

plot(d_comp3, vertex.color="red", main="Komponente 3")

#Cluster innerhlab der Komponente
?cluster_edge_betweenness()

eb <- cluster_edge_betweenness(d_comp3)
eb #2 Gruppen mit Modularität 0.024

plot(eb, d_comp3,
     edge.arrow.size=.2,
     main="Edge-Betweenness-Cluster")

```

```{r Walktrap vs. Edge-Betweenness}
par (mfrow=c(1,2), mar=c(0,0,2,1))
plot(eb, d_comp3, edge.arrow.size=.2, main="Walktrap Cluster")
plot(cl,d_comp3, edge.arrow.size=.2, main="Edge Betweenness Cluster")

```
##  Dyaden und Reziprozität
```{r Dyaden }
#Berechnung der Dyaden
decompose.graph(d) 

dd <- delete_edge_attr(d, "position")
dd <- delete_edge_attr(d, "year")
d_sim <- simplify(dd, edge.attr.comb = list(weight="sum"))
is_simple(d_sim)

#Dyadenzensus
dyad_census(d_sim) 
## $mut
## [1] 0
##
## $asym
## [1] 32
##
## $null
## [1] 1096

#Reziprozität
reciprocity(d_sim, mode="ratio") #0
 

```
Die Berechnung des Dyaden Zensus zeigt, dass es in unserem Netzwerk 27 reziproke (einseitige), 32 einseitige, und 1096 nicht existierende Beziehungen gibt. Es ist also ein nicht eng vernetztes Netzwerk. Die Reziprozität zeigt, dass es in dem Modelabel-Netzwerk *wenige* bis *keine* wechselseitigen Verbindungen gibt.

### Triaden

```{r Triaden}
?triad_census

#Triaden im Netzwerk
triad_census(d_sim)
#genauerer Blick auf die Triaden
motifs(d_sim, size=3)
count_motifs(d_sim, size=3)
#Es gibt 23 triadische Strukturen

#Cliquen
clique_num(d_sim)
#2 

#Größte Clique
lc <- largest_cliques(d_sim)
lc

#Visualisierung der Clique
V(d_sim)$label <- V(d_sim)$name 
d_lc <- subgraph(d_sim, lc[[1]])

plot(d_lc, 
     layout=layout.fruchterman.reingold, vertex.color="gold",
edge.arrow.size = 0.5,
edge.color = "pink",
main = "Größte Clique im Mode Netzwerk")

```
In dem Modelabel Netzwerk gibt es 23 Triaden. Cliquen geben an, wie viele triadische Strukturen komplett rezirpok sind. Dies bedeutet, dass alle drei Akteure eine Beziehung zu einander haben. In unserem Netzwerk gibt es 2 Cliquen.


```

## Zentralitätsmaße (Zehra Sahin)

Je nach Auswahl des Netzwerks unterscheiden sich die Analyseergebnisse
stark. Deshalb ist es notwendig zunächst zu klären, welche Netzwerke
untersucht werden sollen.

Damit die Daten konsistent bleiben werden hier das vereinfachte
Gesamtnetzwerk sowie die vereinfachten Unternetzwerke erneut erstellt.
Das ist in der Regel nicht notwendit, dient hier aber der Absicherung
der Datenkonsistenz.

```{r Zentralitätsmaße: vereinfachte Netzwerke, message=FALSE, warning=FALSE, paged.print=FALSE}

# Netzwerk einlesen und vereinfachen für Analyse
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
is_simple(s_sim)

# Teilnetzwerke
work <- subgraph.edges(s, E(s)[relation==1]) 
help <- subgraph.edges(s, E(s)[relation==2])
love <- subgraph.edges(s, E(s)[relation==3])

work <- delete_edge_attr(work, "relation")
work <- delete_edge_attr(work, "complicated")

help <- delete_edge_attr(help, "relation")
help <- delete_edge_attr(help, "complicated")

love <- delete_edge_attr(love, "relation")

#Vereinfachung 
w_sim <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(w_sim)

h_sim <- simplify(help,edge.attr.comb=list(weight="sum"))
is_simple(h_sim)
```

### Degree

**Degree-Werte allgemein** Analyse des Knotens mit den häufigsten
starken Beziehungen:

```{r Zentralität: Degree-Werte allgemein}

# 1. Knoten mit den stärksten Beziehungen im Gesamtnetzwerk
degree(s, mode="all")
which.max(degree(s, mode="all"))

# 2. Vergleich mit dem vereinfachten Netzwerk
# Vergleich mit dem einfachen simplified Netzwerk
degree(s_sim, mode="all")
which.max(degree(s_sim, mode="all"))

# 3. Teilnetzwerke 
# 3.1 Zusammenarbeit
degree(w_sim, mode="all")
which.max(degree(w_sim, mode="all"))
# 3.2 Ratsuche
degree(h_sim, mode="all")
which.max(degree(h_sim, mode="all"))

```

Der Vergleich der Netzwerke zeigt: - für das Gesamtnetzwerk: Knoten 18
mit einem Degree-Wert von 21 - im vereinfachten Gesamtnetzwerk: Knoten
18 mit einem Degree-Wert von 18 - Teilnetzwerk Work (vereinfacht):
Knoten 19 mit einem Degree-Wert von 8 - Teilnetzwerk Help
(verereinfacht): Knoten 18 mit einem Degree-Wert von 19

Die absoluten Zahlen sind allerdings nur begrenzt aussagekräftig:
Deshalb lässt sich der Degree-Wert leicht normalisieren, d.h. als
Prozentwert darstellen. Deshalb werden wir folgend nur noch mit den
prozentualen Werten arbeiten. Diese Methode nennt sich Normalisierung
und berechnet den Degree-Wert eines Knotens im Verhältnis zu allen
anderen Knoten. Damit erreicht man eine genauere Aussage als mit einem
reinen numerischen Wert. Dafür wird der Befehl um das Argument
normalized = TRUE ergänzt.

```{r Zentralität: Degree-Werte zentralisiert, include=FALSE}

# 1. Knoten mit den stärksten Beziehungen im Gesamtnetzwerk
degree(s, mode="all", normalized = TRUE)
which.max(degree(s, mode="all"))

# 2. Vergleich mit dem vereinfachten Netzwerk
# Vergleich mit dem einfachen simplified Netzwerk
degree(s_sim, mode="all", normalized = TRUE)
which.max(degree(s_sim, mode="all"))

# 3. Teilnetzwerke 
# 3.1 Zusammenarbeit
degree(w_sim, mode="all", normalized = TRUE)
which.max(degree(w_sim, mode="all"))
# 3.2 Ratsuche
degree(h_sim, mode="all", normalized = TRUE)
which.max(degree(h_sim, mode="all"))

```

Der Vergleich der Netzwerke zeigt: - für das Gesamtnetzwerk: Knoten 18
hat 56,76% aller Degree-Werte.\
- im vereinfachten Gesamtnetzwerk: Knoten 18 hat 48,46% aller
Degree-Werte. - Teilnetzwerk Work (vereinfacht): Knoten 19 hat 21,62%
aller Degree-Werte. - Teilnetzwerk Help (verereinfacht): Knoten 18 mit
40,54% aller Degree-Werte.

Mit den normalisierten, d.h. ins Verhältnis gesetzten Zahlen lassen sich
viel genauere Aussagen über die positionalen Maße treffen.

**Indegree als Popularitätsmaß** Das Zentralitätsmaß Indegree wird
häufig als Popularitätsmaß interpretiert. In diesem

```{r Zentralität: Indegree als Popularitätsmaß, include=FALSE}

# Gesamtnetzwerk (vereinfacht)
# zeigt die normalisierte Indegree-Verteilung im vereinfachten Gesamtnetzwerk
degree(s_sim, mode="in", normalized = TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
which.max(degree(s_sim, mode="in"))

# 1. Work-Netzwerk: 
# zeigt die einfache Zentralität im Netzwerk der stärksten Beziehungen an
degree(w_sim, mode="in", normalized = TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
which.max(degree(w_sim, mode="in"))

# 2. Help-Netzwerk
degree(h_sim, mode="in", normalized = TRUE)
which.max(degree(h_sim, mode="in"))

# 3. Love-Netzwerk
degree(love, mode="in", normalized = TRUE)
which.max(degree(love, mode="in"))

```

**Wer ist besonders beliebt im Netzwerk?** Das Zentralitätsmaß
"indegree" liefert eine Auskunft darüber, wer in einem Netzwerk
besonders populär ist. Betrachtet werden die

*Gesamtnetzwerk*: Knoten 18 scheint im Gesamtnetzwerk mit einem Wert
35,13% der beliebteste Knoten zu sein.

*Zusammenarbeit*: Knoten 19 ist am beliebtesten bei der Zusammenarbeit:
16,21% aller Indegrees entfallen auf diesen Knoten. *Unterstützung*:
Knoten 18 vereint 35,13% aller Ratsuchenden auf sich. *Liebesbeziehung*:
Knoten 23 hat den mit 22,72% ein hohes Maß an Popularität

### Betweeness und Broker im Netzwerk

Der Zentralitätswert "Betweenness" zeigt, wie relevant einzelne Knoten
für die Vernetzung zu anderen Knoten sind. Es geht also um Brücken oder
Broker, die zwischen den einzelnen Netzwerken verbinden können.

```{r Zentralität: Betweenness als Broker, echo=FALSE, fig.height=10, fig.width=16, message=FALSE, warning=FALSE, paged.print=FALSE}

# Gesamtnetzwerk (vereinfacht)
# zeigt die normalisierte Indegree-Verteilung im vereinfachten Gesamtnetzwerk
betweenness(s_sim, normalized = TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
which.max(betweenness(s_sim))

# 1. Work-Netzwerk: 
# zeigt die einfache Zentralität im Netzwerk der stärksten Beziehungen an
betweenness(w_sim, normalized = TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
which.max(betweenness(w_sim))

# 2. Help-Netzwerk
betweenness(h_sim, normalized = TRUE)
which.max(betweenness(h_sim))

# 3. Love-Netzwerk
betweenness(love, normalized = TRUE)
which.max(betweenness(love))

# weist dem Broker im vereinfachten Gesamtnetzwerk eine Farbe zu
V(s_sim)[V(s_sim)$name == 18]$vertex.color <- "red"

plot(s_sim, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="gold",
     # vertex.color="gold",
     # vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Broker im Netzwerk",
     sub="vereinfachtes Hauptnetzwerk")

```

### Closeness

```{r Zentralität: Closeness, fig.height=10, fig.width=16, message=FALSE, warning=FALSE, paged.print=FALSE}
# Closeness 
??closness
# Closeness ist ein Zentralitätmaß, das berechnet, welche Knoten eng miteinander verbunden sind. Allerdings kann das Zentralitätsmaß nur bei Netzwerken eingesetzt werden, die nicht über mehrere Komponenten verfügen. Deshalb analysieren wir in diesem Beispiel nur die Hauptkomponente des vereinfachten Netzwerks und erstellen diese zunächst neu.


# Netzwerk neu einlesen und Komponenten isolieren
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
# Vereinfachtes Hauptnetzwerk
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
s_sim <- simplify(ss,edge.attr.comb=list(weight="sum"))
# Komponenten auftrennen
s_comp <- decompose.graph(s_sim)
s_comp
# Komponenten neu benennen
s_comp1 <- s_comp[[1]]
s_comp2 <- s_comp[[2]]
# neue Teilkomponenten analysieren
s_comp1
s_comp2
 
 
# Closeness
# Closness berechnet die relative Nähe zu anderen Knoten. Damit lässt sich interpretieren, welche Knoten im Netzwerk eine zentrale Rolle haben.

close <- closeness(s_comp1, mode="all", normalized=TRUE)
# liefert den Knoten mit der höchsten Anzahl von starken Beziehungen
close
which.max(close)
which.min(close)

# weist den größten und kleinsten Werten eine Randfarbe zu
V(s_comp1)[V(s_comp1)$name == 32]$frame.color <- "red"
V(s_comp1)[V(s_comp1)$name == 18]$frame.color <- "green"

plot(s_comp1, layout=layout_with_kk,
     edge.arrow.size=.4,
     edge.color="gold",
     vertex.color="gold",
     # vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Hauptkomponente",
     sub="Closeness-Werte illustriert")
     

```

In der Hauptkomponente hat Knoten 32 mit einem Wert von 35,63% die
höchste Closness-Zentralität, die niedrigste hat Knoten 18 mit 13,77%.

### Spezialfall: Influencer (Bonus)

Wenn es um einflussreiche Knoten in einem Netzwerk geht, gibt es ein
Spezialpaket InfluenceR, das zusätzlich installiert werden kann. Damit
wird es sehr einfach, einflussreiche Knoten auszulesen. Allerdings
funktioniert das Paket nur bei ungerichteten Knoten, deshalb werden wir
das Netzwerk neu erstellen.

```{r InfluencerR Paket: Analyse von einflussreichen Knoten, fig.height=8, fig.width=12, message=FALSE, warning=FALSE, paged.print=FALSE}

# Installation InfluenceR Programmbibliothek (nur, falls nötig)
# install.packages("influenceR")

library(igraph)
library(influenceR)

# Einlesen des Netzwerks als ungerichtetes Netzwerk und entsprechende Vereinfachung

library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=FALSE)
# Vereinfachtes Hauptnetzwerk
ss <- delete_edge_attr(s, "relation")
ss <- delete_edge_attr(s, "complicated")
ssu <- simplify(ss,edge.attr.comb=list(weight="sum"))
# neues ungerichtetes simplifiziertes Netzwerk für InfluenceR Analyse
ssu

# Was macht die Programmbibliothek InfluenceR?
??influenceR

# Wir erhalten einige neue Funktionen hinzu:
# 1. ens(g) berechnet den Zugang zu strukturellen Löchern in einem Netzwerk
# 2. bridging(g) berechnet die Knoten, die es ermöglichen, schneller andere Knoten zu erreichen, sogenannte Brücken. (nach Valente)

holes <- ens(ssu)
which.max(holes)

bridges <- bridging(ssu)
which.max(bridges)

# weist den größten und kleinsten Werten eine Randfarbe zu
V(ssu)[V(ssu)$name == 18]$color <- "green"
V(ssu)[V(ssu)$name == 5]$color <- "blue"

plot(ssu, layout=layout_nicely,
		 asp=0,
     edge.arrow.size=.4,
     edge.color="gold",
		 vertex.size=10,
     # vertex.color="gold",
		 vertex.frame.color=NA,
     vertex.label.color="black",
     edge.curved=.2,
     edge.curved=curve_multiple(s_comp1),
     main="Einflussreiche Knoten",
     sub="Strukturelle Löcher (grün) und Brücken (blau)")

```

Mit der Programmbibliothek InfluenceR ließen sich zwei weitere relevante
Knoten isolieren, die für die Konfiguration des Netzwerks (im Falle
eines ungerichteten Netzwerks) relevant sind: Knoten 18 ermöglicht es,
sogenannte strukturelle Löcher im Netzwerk anzusprechen während Knoten 5
eine Brückenfunktion übernimmt.

## Erklärungsmuster: Reziprozität, Transitivität, Homophilie

Für die Struktur von Netzwerken liegen einige Erklärungsmuster vor, dazu gehören Reziprozität, Transitivität und Homophilie.

Reziprozität ist die gegenseitige Anerkennung in Netzwerken, d.h. dass Knoten (in gerichteten Netzwerken) gegenseitig gegenseitig verbunden sind. Transitivität beschreibt die Möglichkeit, dass zwischen Knoten eine Weitergabe stattfindet während Homophilie die Ähnlichkeit von Knoten betont.

```{r Erklärungsmuster: Gesmatnetzwerk d}
library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Edgelist%20(1).csv", strip.white = TRUE)
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Nodelist%20(1).csv", strip.white = TRUE)
edgematrix <- as.matrix(edges)
d <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# Da es uns um Erklärungsmuster geht, werden die Nezwerke nicht vereinfacht

```

```{r Erklärungsmuster: Teilnetzwerk director}

library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/director%20Teilnetzwerk%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/director%20Teilnetzwerk%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)
director <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

```

```{r r Erklärungsmuster: Teilnetzwerk assistant}
library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/assistant%20Teilnetzwerk%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/assistant%20Teilnetzwerk%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)
assistant <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
```

```{r r Erklärungsmuster: Teilnetzwerk founder}
library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/founder%20Teilnetzwerk%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/founder%20Teilnetzwerk%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)
founder <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
```

```{r Erklärungsmuster: Teilnetzwerk muse}
library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/muse%20Teilnetzwerk%20-%20Edgelist.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/muse%20Teilnetzwerk%20-%20Nodelist.csv", header=T, as.is=T, sep = ",")
edgematrix <- as.matrix(edges)
muse <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
```

### Reziprozität

Für die Berechnung der Reziprozität im Netzwerk verwenden wir das vereinfachte Gesamtnetzwerk.

```{r Reziprozität}
??reciprocity
reciprocity(d)
reciprocity(director)
reciprocity(assistant)
reciprocity(founder)
reciprocity(muse)
```

Die Reziprozität beträgt sowohl im **Gesamtnetzwerk** als auch in den **Teilnetzwerken** Null. Dies deutet darauf hin, dass es keine wechselseitigen Verbindungen zwischen den einzelnen Knotenarten (Designern, Brands und Musen) gibt. In unserem Netzwerk sind die Beziehungen von einer Seite aus, von den Desigern zu den Brands oder Musen und von den Musen zu den Brands, initiiert. Wir haben also eine Netzwerk erstellt, in dem Designer hauptsächlich Ideen oder Kreationen an Brands oder Musen weitergeben, ohne dass es eine direkte Rückkopplung von Brands oder Musen zurück zu den Designern gibt.

### Transitivität

Transitivität ist eng mit Triaden oder "Tripletts" verbunden (vgl. z.B. Hummel & Sodeur 2010).

```{r Transitivität}
??transitivity
transitivity(d)
transitivity(assistant) 
transitivity(director)
transitivity(founder)
transitivity(muse) 
```

Im **Gesamtnetzwerk** liegt eine Transivität von ungefähr 21,1% vor. Das heißt, dass in nahezu in einem Viertel der Beziehung eine Inhaltsweitergabe über triadische Strukturen vorliegt. Insgesamt wechseln einige Designer zweimal eine Marke. Was heißt, dass einige Designer den Informationsfluss zwischen den Brands steuren und eine Gatekeeper Funktion haben. (siehe Karl Lagerfeld) In dem **Teilnetzwerk "founder"** gibt es keine Transivität, da dort nur die Verbindungen zwischen Gründer und Marke angezeigt werden. Bei den **Teilnetzwerken "director"** und **"assistant"** gibt es keine triadische Strukturen, da die ausgewählten Designer diese Positionen in Unternehmen selten genau zweimal antreten. Designer führen die selbe Position meistens wenn dann, einmal oder mindestens dreimal durch.Im Teilnetzwerk "muse" herrscht eine starke Vernetzung, die über triadische Strukturen hinausgeht.

Gründe:

-   einmaliger Wechsel im "assistant"-/"director"- Teilnetzwerk: Position als Karrieresprungbrett, Gründung von eigenem Label, Designer als Markengesicht

-   mehrere Wechsel: Ausprobieren, Unzufriedenheit

### Homophilie

Die Homophilie untersucht die Strukturähnlichkeit von Knoten in Netzwerken.

```{r Homophilie}
# igraph verwendet zur Berechnung von Homophilie den Wert Assortivität: Dieser Wert gilt als positiv, wenn sich ähnliche Knoten (aufgrund deren Eigenschaften) miteinander verbinden. Ansonsten wird der Wert negativ berechnet.
??assortativity
list.vertex.attributes(d)

# Assortivität im Hauptnetzwerk 
assortativity_nominal(d, V(d)$value, directed=TRUE)
assortativity_nominal(d, V(d)$sex, directed=TRUE)
assortativity_nominal(d, V(d)$sexuality, directed=TRUE)
assortativity_nominal(d, V(d)$birthyear, directed=TRUE)
assortativity_nominal(d, V(d)$scholar, directed=TRUE)
assortativity_nominal(d, V(d)$transfer, directed=TRUE)

# Assortivität im Teilnetzwerk muse
assortativity_nominal(muse, V(muse)$value, directed=TRUE)
assortativity_nominal(muse, V(muse)$sexuality, directed=TRUE)
assortativity_nominal(muse, V(muse)$sex, directed=TRUE)
assortativity_nominal(muse, V(muse)$birthyear, directed=TRUE)
assortativity_nominal(muse, V(muse)$scholar, directed=TRUE)
assortativity_nominal(muse, V(muse)$transfer, directed=TRUE)

# Assortivität im Teilnetzwerk director 
assortativity_nominal(director, V(director)$sex, directed=TRUE)
assortativity_nominal(director, V(director)$value, directed=TRUE)
assortativity_nominal(director, V(director)$sexuality, directed=TRUE)
assortativity_nominal(director, V(director)$birthyear, directed=TRUE)
assortativity_nominal(director, V(director)$scholar, directed=TRUE)

# Assortivität im Teilnetzwerk assistant 
assortativity_nominal(assistant, V(assistant)$sex, directed=TRUE)
assortativity_nominal(assistant, V(assistant)$value, directed=TRUE)
assortativity_nominal(assistant, V(assistant)$sexuality, directed=TRUE)
assortativity_nominal(assistant, V(assistant)$birthyear, directed=TRUE)
assortativity_nominal(assistant, V(assistant)$scholar, directed=TRUE)
assortativity_nominal(assistant, V(assistant)$transfer, directed=TRUE)
```

#### Gesamtnetzwerk:

Der Wert für das Attribut "value" im **Gesamtnetzwerk** ist positiv (0.07169886). Dies deutet darauf hin, dass ähnliche Knoten wie z.B., Designer mit ähnlichen Vermögen oder Marktwert eher miteinander verbunden sind.Der Wert für das Attribut "sex" liegt nahe bei -1, was zeigt, dass Knoten unterschiedlichen Geschlechts eher miteinander verbunden sind (mehr dazu bei der Assortivität des Musen Netzwerks). Andere Attribute wie "sexuality", "birthyear", "scholar" und "transfer" zeigen keine signifikante Homophilie (Assortativität nahe bei 0), was darauf hindeutet, dass es keine klare Tendenz gibt, dass ähnliche Werte dieser Attribute sich miteinander verbinden.

#### Teilnetzwerk "muse":

Die value-Variable hat eine starke negative Assortativität von etwa -0,4. Dies zeigt an, dass im Teilnetzwerk der Musen eine Tendenz besteht, sich mit Knoten zu verbinden, die ein höheres Vermögen als sie aufweisen. Es herrscht mit einer Assortivität von -0,23 des Attributs "sex" auch eine starke Tendenz der Knoten, sich mit dem gegensätzlichen Geschlecht zu verbinden. Die Musen sind meist weiblich und die Designer meistens männlich.Die anderen Variablen besitzen eine Assortivität gleich Null, also keine relevante Homopholie.

#### Teilnetzwerke "director" und "assistant":

In diesen Teilnetzwerken ist die Assortativität für die betrachteten Variablen (sex, sexuality, birthyear, scholar, transfer) gleich Null. Das bedeutet, dass in diesen spezifischen Teilnetzwerken keine ausgeprägten Tendenzen zu einer Verbindung mit ähnlichen Knoten in Bezug auf diese Attribute bestehen.In den Teilnetzwerken herrscht eine Tendenz zwischen den Knoten Verbindungen mit ähnlichem value-Atrribut einzugehen (ähnlich wie im Gesamtnetzwerk, jedoch deutlich geringerer Wert).

# Visualisierung

## Gesamtnetzwerk

```{r Visualisierung Gesamtnetzwerk , fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
library(igraph)
library(ggraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Edgelist%20(1).csv", strip.white = TRUE)
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Nodelist%20(1).csv", strip.white = TRUE)
edgematrix <- as.matrix(edges)
d <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(d)
plot(d)
dd <- delete_edge_attr(d, "position")
dd <- delete_edge_attr(d, "year")
dd <- delete_vertex_attr(d, "name")# löscht den Vertex-Atributt "name", da das Netzwerk sonst zu unübersichtlich ist
d_sim <- simplify(dd,edge.attr.comb=list(weight="sum"))

# Plotting 

# definiert die Ränder (unten, link, oben, rechts)
par(mar=c(10,1,8,1))

# Größe des Plots setzen
options(repr.plot.width = 8, repr.plot.height = 6) 

library(igraph)
plot(d_sim,
     asp = 0,
     layout = layout_with_fr(d_sim), # Layout-Algorithmus "Fruchterman-Reingold" zur besseren Übersicht,
     vertex.size = degree(d_sim, mode = "all"), 
     vertex.label.cex = 1,
     vertex.frame.color = NA,
     edge.arrow.size = 0.7,
     edge.color = "black",
     edge.width = E(d_sim)$weight / 4, #Wert der Gewichte durch vier für eine bessere Darstellung
     edge.curved = 0.2,
     edge.curved = curve_multiple(d_sim),
     )

title("Gesamtnetzwerk vereinfacht", 
      sub = "aggregierte Gewichte von position und year",
      cex.main = 2, col.main = "orange",
      cex.sub = 1.5, font.sub = 3, col.sub = "black")

par(mar = c(2, 2, 2, 2))


```

```{r Visualisierung von Farbverläufen von Werten, fig.height=8, fig.width=12, message=FALSE, warning=FALSE, paged.print=FALSE}

library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Edgelist%20(1).csv", strip.white = TRUE)
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Nodelist%20(1).csv", strip.white = TRUE)
edgematrix <- as.matrix(edges)
d <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(d)
dd <- delete_edge_attr(d, "position")
dd <- delete_edge_attr(d, "year")
dd <- delete_vertex_attr(d, "name")
d_sim <- simplify(dd,edge.attr.comb=list(weight="sum"))

# Berechnung des Indegree-Werts normalisiert
ins <- degree(d, mode = "in", normalized = TRUE)

# legt die Farbskala fest
palette = colorRampPalette(c('lightblue','darkblue'))

# die Palette wird in 10 Schritte unterteilt.
fine = 10
graphCol = palette(fine)[as.numeric(cut(ins, breaks = fine))] 

# der folgende Plot ist um einige weitere Visualisierungsparameter ergänzt

par(mar=c(10,1,10,1))

plot(d, 
     asp=0,
     rescale=TRUE,
     layout=layout_nicely,
     vertex.color=graphCol, #verwende als Farbe die Farbpalette 
     vertex.label=NA,
     vertex.size=6, # hier könnte auch die Größe der indegrees gesetzt werden
     vertex.frame.color = "white", 
     edge.color="lightblue", 
     edge.width=E(d_sim)$weight/2, 
     edge.curved=.2,
     edge.curved=curve_multiple(d)
)

title("Was sind die Hauptquellen der Einflussnahme auf Designer, Marken und Musen? 
Eine Analyse des Indegree-Werts im Netzwerk. (n=145)", 
      sub = "Visualisierung nach normalisierter Indegree-Verteilung",
      cex.main = 1.5, col.main= "darkblue",
      cex.sub = 1.5, font.sub = 3, col.sub = "black")

```

### Gesamtnetzwerk nach Node-Attribut: Knotenart und Geschlecht

```{r Geschlechtsverteilung, fig.height=8, fig.width=10, message=FALSE, warning=FALSE, paged.print=FALSE}

library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Edgelist%20(1).csv", strip.white = TRUE)
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Nodelist%20(1).csv", strip.white = TRUE)
edgematrix <- as.matrix(edges)
d <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(d)
list.vertex.attributes(d)
dd <- delete_edge_attr(d, "position")
dd <- delete_edge_attr(d, "year")
dd <- delete_vertex_attr(d, "name")
d_sim <- simplify(dd,edge.attr.comb=list(weight="sum"))
d <- simplify(dd,edge.attr.comb=list(weight="sum"))

# Farben und Formen setzen

# weist den Attributswerten entsprechende Farben zu
V(d)[V(d)$sex == 1]$color <- "pink"
V(d)[V(d)$sex == 2]$color <- "lightblue"


# weist den Attributswerten der position entsprechende Formen zu
vertex.attributes(d)$type
V(d)[V(d)$type == 1]$shape <- "sphere"  
V(d)[V(d)$type == 3]$shape <- "square"
V(d)[V(d)$type == 2]$shape <- "circle"

# normalize_01-Funktion definieren
normalize_01 <- function(x) (x - min(x)) / (max(x) - min(x)) + 0.25

legend1 <- data.frame(attr = unique(vertex_attr(d, "type")),
                          color = unique(V(d)$color))
legend1 <- legend1[order(legend1$attr), c(1,2)]
legend_labels1 <- c("männlich", NA, "weiblich")
legend_labels2 <-c("brand", "muse", "designer")

# definiert die Ränder (unten, link, oben, rechts)
par(mar=c(10,1,8,1))

# Größe des Plots setzen
options(repr.plot.width = 8, repr.plot.height = 6) 

library(igraph)
plot(d,
     asp = 0,
     layout = layout_with_fr(d, niter = 1000, coords = NULL), # Layout-Algorithmus "Fruchterman-Reingold" zur besseren Übersicht
     vertex.size = normalize_01(degree(d, mode = "all")) * 10, # Größe an die normalisierte Degree-Zentralität anpassen
     vertex.frame.color = "black",
     edge.arrow.size = 0.5,
      edge.arrow.width = 2, 
     vertex.label.color="black",
     edge.color="lightgray",
     edge.lty = "solid",
     edge.width = E(d_sim)$weight / 4, # Wert der Gewichte durch vier für eine bessere Darstellung
     edge.curved = 0.05,
     vertex.label.family = "Verdana",
      vertex.label.font = 2, #font face
       vertex.label.cex = normalize_01(degree(d)) * 1.5,) # font expansion factor

# erste Legende hinzufügen 
legend(x = "bottomleft",      # position, also takes x,y coordinates
      legend = legend_labels1,
       pch = 19,              # legend symbols see ?points
      col = legend1$color,
       title = "Geschlecht",
      pt.cex = 2,  # Anpassen der Symbolgröße in der Legende
       cex = 1,   # Anpassen der Textgröße in der Legende
       bg = "white",  # Hintergrundfarbe für die Legende
)

#zweite Legende hinzufügen
legend(x = "bottomright",
       legend = legend_labels2,
       pch = c(1, 19, 15),  # Anpassen der Symbole für die verschiedenen Formen (es gab keine Form für "sphere", deswegen pch = 19)
       col = "black",
       title = "Typus",
       pt.cex = 2,  # Anpassen der Symbolgröße in der Legende
       cex = 1,   # Anpassen der Textgröße in der Legende
       bg = "white",  # Hintergrundfarbe für die Legende
)

# Plot-Titel und Untertitel
title("Gesamtnetzwerk: Knotenart (designer, muse, brand) 
      und Geschlecht", 
      sub = "Knotenart und Geschlecht",
      cex.main = 1.5, col.main= "black",
      cex.sub = 1.5, font.sub = 3, col.sub = "black")

par(mar=c(2,2,2,2))

```

### Multiplexes Netzwerk

Um das etwas übersichtlicher darszustellen, bietet sich bei einem Netzwerk mit verschiedenen Beziehungsarten an, diese farblich zu unterscheiden.

```{r Visualisierung eines multiplexe Netzwerke erstellen, fig.height=8, fig.width=10}

library(igraph)
edges <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Edgelist%20(1).csv", strip.white = TRUE)
nodes <- read.csv("https://raw.githubusercontent.com/cp071/Project-fashion-designer/main/Gesamtnetzwerk%20%20-%20Nodelist%20(1).csv", strip.white = TRUE)
edgematrix <- as.matrix(edges)
d <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# Finde die Vertices, die das Attribut "type" mit dem Wert 1 haben
vertices_to_delete <- which(V(d)$type == 1)

# Lösche die ausgewählten Vertices, da die Musen in dem Netzwerk irrelevant sind
d <- delete_vertices(d, vertices_to_delete)


# definiert die Farbe der Relation
E(d)[E(d)$position == "founder"]$color <- "blue" 
E(d)[E(d)$position == "assistant"]$color <- "darkgreen"
E(d)[E(d)$position == "director"]$color <- "red"

# weist den Attributswerten der position entsprechende Formen zu
vertex.attributes(d)$type
V(d)[V(d)$type == 3]$shape <- "square"
V(d)[V(d)$type == 2]$shape <- "circle"

#Legende erstellen
legend_labels3 <- c("founder", "assistant", "director")
legend_colors3 <- c("blue", "darkgreen", "red")
legend_labels2 <-c("brand", "designer")

# Plot mit den gesetzten Farben für das Attribut Beziehung realisieren

# Visualisierungsparameter festlegen
par(mar=c(6,3,3,3)) 

# Plot mit den gesetzten Farben für das Attribut Beziehung realisieren
plot(d,
     asp=0,
     layout = layout_with_kk(d, coords = NULL),
     edge.arrow.size=.5,
     edge.arrow.width = 2, 
     vertex.color="lightgray",
     edge.lty = "solid",
     vertex.frame.color="black",
      vertex.label.color="black",
     vertex.size=6,
     vertex.label.family = "Verdana",
     edge.curved=curve_multiple(d),
     edge.curved = 0.05,
     main="Multiplexes Netzwerk - verschiedene Positionen der Designer",
     
)

legend(x = "bottomleft",
       legend = legend_labels3,
       pch = 19,
       col = legend_colors3,
       title = "Position",
       pt.cex = 2,
       cex = 1,
       bg = "white")

#zweite Legende hinzufügen
legend(x = "bottomright",
       legend = legend_labels2,
       pch = c(1, 19, 15),  # Anpassen der Symbole für die verschiedenen Formen (es gab keine Form für "sphere", deswegen pch = 19)
       col = "black",
       title = "Typus",
       pt.cex = 2,  # Anpassen der Symbolgröße in der Legende
       cex = 1,   # Anpassen der Textgröße in der Legende
       bg = "white",  # Hintergrundfarbe für die Legende
)

# setzt die Seitenaufteilung zurück
par(mfrow=c(1,1), mar=c(2,0,2,0))  


```

# Diskussion: Fazit, Limitationen und Ausblick

**Arbeitshypothesen:** Im Verlauf des Netzwerkforschungsprojekts wurden anfänglich bestimmte Annahmen getroffen, wie beispielsweise die Vermutung, dass bestimmte Geschlechterstereotype in den Beziehungen zwischen Designern, Brands und Musen vorhanden sind. Die Annahme über die Nationalität der Marke und des Designers wurde ebenfalls geprüft.

**Bestätigung oder Widerlegung von Hypothesen:** Die Analyse hat einige interessante Ergebnisse hervorgebracht. Die meisten Designer waren männlich, während die Musen überwiegend weiblich waren, was dem Geschlechterstereotyp entspricht. Diese Hypothese wurde somit bestätigt. Jedoch wurde die Annahme über den Zusammenhang zwischen der Nationalität der Marke und des Designers widerlegt, da in der Studie kein signifikanter Zusammenhang festgestellt werden konnte.

**Neue Erkenntnisse:** Die Analyse hat wichtige Erkenntnisse über die Geschlechterverteilung unter Designern und Musen geliefert. Die Untersuchung hat gezeigt, dass bestimmte Stereotypen in diesem Bereich existieren, jedoch wurde auch deutlich, dass Stereotype nicht in allen Aspekten der Beziehungen zwischen Designern, Brands und Musen bestätigt werden können.

**Limitationen der Studie:** Es gibt bestimmte Einschränkungen in der Studie, wie beispielsweise die Möglichkeit von Verzerrungen aufgrund der Datenquelle oder der begrenzten Datenverfügbarkeit. Zusätzlich könnten andere Faktoren, die nicht untersucht wurden, ebenfalls einen Einfluss auf die Beziehungen zwischen Designern, Brands und Musen haben.

**Ausblick und nächste Schritte:** Ein qualitatives Interview mit Modeexperten im Rahmen der Erstellung des Edit-Beitrags Umfragen qird auf unserer Studie aufbauend, durchgeführt, um ein umfassenderes Verständnis für die Dynamiken und Gründe hinter den Netzwerkverbindungen zu erhalten. In der Forschung könnten weitere Analysen durchgeführt werden, die zusätzliche Variablen einbeziehen, um die Beziehungen innerhalb des Netzwerks genauer zu untersuchen. Außerdem könnte eine Erweiterung der Datenquellen und -größen weitere Einblicke in die Beziehungen zwischen den Akteuren bieten und so eine umfassendere Analyse ermöglichen.

### Fazit:

Das Netzwerkforschungsprojekt hat wichtige Einblicke in die Beziehungen zwischen Designern, Brands und Musen geliefert. Während einige anfängliche Annahmen bestätigt wurden, widerlegte die Studie andere Hypothesen. Die Analyse bestätigte das Geschlechterstereotyp in der Verteilung von Designern und Musen, fand jedoch keinen Zusammenhang zwischen der Nationalität von Marken und Designern. Trotz einiger Limitationen bietet diese Studie eine Grundlage für zukünftige Forschungen, die sich auf eine erweiterte und vertiefte Analyse der Netzwerkbeziehungen zwischen den Akteuren konzentrieren könnten.

# Anlage

## Literatur

Dunkake I. (2012). Soziale Netzwerke von Schülern: Beispiele angewandter Netzwerkanalysen. In: Hennig M. & Stegbauer C. (Hg.): Die Integration von Theorie und Methode in der Netzwerkforschung. Wiesbaden: VS Verlag für Sozialwissenschaften, S. 133-155.

Hummel & Sodeur (2010). Dyaden und Triaden. In: Stegbauer, C. & Häußling, R. (Hg.): Handbuch Netzwerkforschung. Wiesbaden: VS Verlag, S.

Krackhardt D. (1987). Cognitive social structures. Social Networks, 9, 104-134.

Luke, D. A. (2015). A user's guide to network analysis in R. Cham, Switzerland: Springer.

Ognyanova, K.(2019). Network Visualization with R. Sunbelt 2019 Workshop, Montreal, Canada. www.kateto.net/sunbelt2019

## Codebuch

[Codebuch](https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md)

```{r Übersicht Netzwerkattribute}
list.vertex.attributes(d)
# vertex.attributes(d)
list.edge.attributes(d)
# edge.attributes(d)
```

Das Netzwerk hat nach dem [Codebuch](https://github.com/hdm-crpr/226305/blob/master/data/crpr2/codebuch.md) folgende Attribute:

*Vertex-Attribute*\
- name: voller Name des Knotens\
- sex: Geschlecht 1 weiblich, 2 männlich, 3 divers\
- birthyear: Geburtsjahr des Knotens\
- main workplace: de deutschland, usa amerika, it italien, fr frankreich, gb england, jap japan, dr Dominikanische Republik, ven venezuela, bra brasilien, wal wales, sp spanien main workplace\
- type: 1 designer, 2 brand, 3 muse - scholar: Abschlussart des Designers, 1 talent : Der/Die Designerin hat bis auf seine kreative Ader keinen Abschluss, 2 internship/work experience : Der/Die Designerin hatte eine Art Ausbildung bei einem Mentor oder praktische Erfahrungen in der Modebranche gesammelt, 3 degree Der/Die Designer*in hat eine Modeschule oder vergleichbares besucht.\
- sexuality: 1 heterosexual, 2 homosexual, 3 bisexual\
- transfer 1 Der/Die Deswignerin hat direkt seine eigene Marke gegründet, 2 Der/Die Designerin hat die Marke ein mal gewechselt, 3 Der/Die Designer*in hat die Marke zwei mal gewechselt, 4 Die Marke wurde drei oder mehrmals gewechselt\
- value: Designervermögen/ Markenwert, 1 1 - 50 Mio. Dollar, 2 55 - 100 Mio. Dollar, 3 105 - 500 Mio. Dollar, 4 505 - 1 Mrd. Dollar, 5 1 Mrd. Dollar oder höher\

Die Vertex-Attribute treffen auf alle Knoten zu.

*Edge-Attribute*\
- position: Designer\*innen Rang innerhalb einer Brand, 1 Jeglicher unterer Rang oder Design Assistant Design Assistant, 2 Creative Director, 3 Founder\
- year: Jahr, in dem der Wechsel stattfand\

## Datenmaterial und Skript

[Datensatz](https://github.com/cp071/Project-fashion-designer/blob/main/README.md)

## Team, Arbeitsaufwand und Lessons Learned

### Teammitglieder

Claire Penga Amelie Eberl Marie Johnson Moritz Kronberger Zehra Sahin Sara Hadzihasanovic

### Arbeitsaufwand und Rollen im Team

NN: Projektleitung und Coding, ca. 40 Stunden\
NN: Literaturrecherche und Auswertung, ca. 50 Stunden\
NN: Endbericht und Visualiserung, ca. 40 Stunden

**MVP** (Most Valuable Member): einstimmige Nominierung, plus 0,3 in der Gesamtnote

### Lessons learned

Im Verlauf des Projekts stellte das Team fest, dass die größte Herausforderung in der Bewältigung von Fehlern und der Fehlerbereinigung lag. Dies war besonders dann herausfordernd, wenn Teammitglieder an verschiedenen Aspekten des Projekts arbeiteten. Es war wichtig, dass das Team eine klare Kommunikation aufrechterhielt, um Fehler frühzeitig zu erkennen und effizient zu beheben, um Zeitverluste zu minimieren und die Qualität der Arbeit sicherzustellen.

Die effektiven Zeiteinteilung und im Zeitmanagement war auch besonders anspruchsvoll. Zu Beginn wurden nicht ausreichend klare Zeitpläne festgelegt, was zu Engpässen und einer ungleichmäßigen Verteilung der Arbeitslast führte. Dies führte zu der Erkenntnis besser zu Plannen, um eine erhöhten Belastung in bestimmten Projektphasen und das potenzielle Risiko, die Kernaufgaben aus dem Blick zu verlieren, zu vermeiden .

Die wichtigste Lernerfahrung war die Anerkennung der Bedeutung des Teamworks und einer koordinierten Zusammenarbeit. Das Team erkannte, dass eine offene Kommunikation und eine klare Verteilung der Aufgaben entscheidend sind, um den Überblick über das gesamte Projekt zu behalten und sicherzustellen, dass die Kernaufgaben nicht vernachlässigt werden. Ein strukturierter Ansatz zur Aufgabenverteilung, regelmäßige Treffen und die Etablierung klarer Verantwortlichkeiten halfen dabei, Hindernisse zu überwinden und den Projekterfolg zu gewährleisten. Diese Lektion betonte die Wichtigkeit eines kooperativen und koordinierten Teamworks für erfolgreiche Projektdurchführungen.
